use get_size::GetSize;
use serde::{Deserialize, Serialize};
use tasm_lib::{
    triton_vm::{
        instruction::LabelledInstruction,
        program::{NonDeterminism, Program},
        triton_asm,
    },
    twenty_first::shared_math::{b_field_element::BFieldElement, bfield_codec::BFieldCodec},
    Digest,
};

use crate::models::consensus::SecretWitness;

#[derive(Debug, Clone, Deserialize, Serialize, BFieldCodec, GetSize, PartialEq, Eq)]
pub struct TimeLock {
    /// milliseconds since the unix epoch (00:00 UTC am on Jan 1 1970).
    release_date: u64,
}

impl TimeLock {
    /// Create a `TimeLock` type script that releases the coins at the given release date,
    /// which corresponds to the number of milliseconds that passed since the unix epoch
    /// started (00:00 am UTC on Jan 1 1970).
    pub fn until(date: u64) -> TimeLock {
        Self { release_date: date }
    }

    pub fn code(&self) -> Vec<LabelledInstruction> {
        let unlock_hi = self.release_date >> 32;
        let unlock_lo = self.release_date & 0xffffffff;

        // Generated by tasm-lang compiler
        // `cargo test -- --nocapture typescript_timelock_test`
        // 2024-02-09
        // Adapted for dynamic unlock date
        triton_asm! {
            call main
            halt
            main:
            push {unlock_hi}
            push {unlock_lo}
            hint unlock_date = stack[0..2]
            call tasm_io_read_stdin___digest
            hint tx_kernel_digest = stack[0..5]
            call tasm_io_read_secin___bfe
            hint timestamp = stack[0]
            push 5
            hint leaf_index = stack[0]
            dup 1
            call encode_BField
            call tasm_langs_hash_varlen
            hint leaf = stack[0..5]
            push 3
            hint tree_height = stack[0]
            dup 12
            dup 12
            dup 12
            dup 12
            dup 12
            dup 11
            dup 11
            dup 11
            dup 11
            dup 11
            dup 11
            dup 11
            call tasm_hashing_merkle_verify
            dup 14
            dup 14
            dup 9
            split
            swap 3
            swap 1
            swap 3
            swap 2
            call tasm_arithmetic_u64_lt_standard
            assert
            pop 5
            pop 5
            pop 5
            return
            encode_BField:
            push 2
            call tasm_memory_dyn_malloc
            push 1
            swap 1
            write_mem 1
            write_mem 1
            push -2
            add
            return
            tasm_langs_hash_varlen:
            read_mem 1
            push 2
            add
            swap 1
            call tasm_hashing_algebraic_hasher_hash_varlen
            return
            tasm_arithmetic_u64_lt_standard:
            call tasm_arithmetic_u64_lt_standard_aux
            swap 4
            pop 4
            return
            tasm_arithmetic_u64_lt_standard_aux:
            dup 3
            dup 2
            lt
            dup 0
            skiz
            return
            dup 4
            dup 3
            eq
            skiz
            call tasm_arithmetic_u64_lt_standard_lo
            return
            tasm_arithmetic_u64_lt_standard_lo:
            pop 1
            dup 2
            dup 1
            lt
            return
            tasm_hashing_absorb_multiple:
            dup 0
            push 10
            swap 1
            div_mod
            swap 1
            pop 1
            swap 1
            dup 1
            push -1
            mul
            dup 3
            add
            add
            push -1
            add
            swap 1
            swap 2
            push -1
            add
            call tasm_hashing_absorb_multiple_hash_all_full_chunks
            pop 1
            push 9
            dup 2
            push -1
            mul
            add
            call tasm_hashing_absorb_multiple_pad_varnum_zeros
            pop 1
            push 1
            swap 2
            dup 1
            add
            call tasm_hashing_absorb_multiple_read_remainder
            pop 2
            sponge_absorb
            return
            tasm_hashing_absorb_multiple_hash_all_full_chunks:
            dup 1
            dup 1
            eq
            skiz
            return
            push 10
            add
            dup 0
            read_mem 5
            read_mem 5
            pop 1
            sponge_absorb
            recurse
            tasm_hashing_absorb_multiple_pad_varnum_zeros:
            dup 0
            push 0
            eq
            skiz
            return
            push 0
            swap 3
            swap 2
            swap 1
            push -1
            add
            recurse
            tasm_hashing_absorb_multiple_read_remainder:
            dup 1
            dup 1
            eq
            skiz
            return
            read_mem 1
            swap 1
            swap 2
            swap 1
            recurse
            tasm_hashing_algebraic_hasher_hash_varlen:
            sponge_init
            call tasm_hashing_absorb_multiple
            sponge_squeeze
            swap 5
            pop 1
            swap 5
            pop 1
            swap 5
            pop 1
            swap 5
            pop 1
            swap 5
            pop 1
            return
            tasm_hashing_merkle_verify:
            hint tree_height: u32 = stack[0]
            hint leaf: Digest = stack[1..6]
            hint leaf_index: u32 = stack[6]
            hint root: Digest = stack[7..12]
            push 2
            pow
            hint num_leaves: u32 = stack[0]
            dup 0
            dup 7
            lt
            assert
            dup 6
            add
            hint node_index: u32 = stack[0]
            swap 6
            pop 1
            call tasm_hashing_merkle_verify_traverse_tree
            swap 1
            swap 2
            swap 3
            swap 4
            swap 5
            pop 1
            assert_vector
            pop 5
            return
            tasm_hashing_merkle_verify_traverse_tree:
            dup 5
            push 1
            eq
            skiz
            return
            divine_sibling
            hash
            recurse
            tasm_io_read_secin___bfe:
            divine 1
            return
            tasm_io_read_stdin___digest:
            read_io 5
            return
            tasm_memory_dyn_malloc:
            push 00000000004294967296
            read_mem 1
            pop 1
            dup 0
            push 0
            eq
            push 00000000004294967297
            mul
            add
            dup 0
            swap 2
            split
            swap 1
            push 0
            eq
            assert
            add
            dup 0
            split
            pop 1
            push 0
            eq
            push 0
            eq
            assert
            push 00000000004294967296
            write_mem 1
            pop 1
            return
        }
    }
}

#[derive(Debug, Clone, Deserialize, Serialize, BFieldCodec, GetSize, PartialEq, Eq)]
pub struct TimeLockWitness {
    time_lock: TimeLock,
    transaction_timestamp: u64,
    mast_path: Vec<Digest>,
}

impl SecretWitness for TimeLockWitness {
    fn nondeterminism(&self) -> NonDeterminism<BFieldElement> {
        NonDeterminism::new(vec![BFieldElement::new(self.transaction_timestamp)])
            .with_digests(self.mast_path.clone())
    }

    fn subprogram(&self) -> Program {
        Program::new(&self.time_lock.code())
    }
}
