use std::{
    sync::{Arc, Mutex},
    time::Duration,
};

use rusty_leveldb::{WriteBatch, DB};
use serde::{Deserialize, Serialize};
use twenty_first::{
    shared_math::tip5::Digest,
    util_types::storage_schema::{
        DbtSchema, DbtSingleton, DbtVec, RustyKey, RustyReader, RustyValue, StorageSingleton,
        StorageWriter, WriteOperation,
    },
};

use crate::models::blockchain::transaction::amount::{Amount, Sign};

use super::monitored_utxo::MonitoredUtxo;

#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
pub struct BalanceUpdate {
    pub block: Digest,

    // use only for display
    pub timestamp: Duration,

    pub amount: Amount,

    pub sign: Sign,
}

impl From<RustyValue> for BalanceUpdate {
    fn from(value: RustyValue) -> Self {
        bincode::deserialize(&value.0)
            .expect("Could not deserialize balance update from database; database seems corrupted.")
    }
}

impl From<BalanceUpdate> for RustyValue {
    fn from(value: BalanceUpdate) -> Self {
        RustyValue(bincode::serialize(&value).expect("Totally nonsensical for serialize to return Result type because it cannot fail, but that is how the interface has been defined."))
    }
}

pub struct RustyWalletDatabase {
    // pub ams: ArchivalMutatorSet<H, AmsMmrStorage, AmsChunkStorage>,
    // schema: DbtSchema<RustyKey, RustyMSValue, RamsReader>,
    schema: DbtSchema<RustyKey, RustyValue, RustyReader>,
    db: Arc<Mutex<DB>>,

    // active_window_storage: Arc<Mutex<DbtSingleton<RustyKey, RustyMSValue, Vec<u32>>>>,
    pub monitored_utxos: Arc<Mutex<DbtVec<RustyKey, RustyValue, u64, MonitoredUtxo>>>,

    pub balance_updates: Arc<Mutex<DbtVec<RustyKey, RustyValue, u64, BalanceUpdate>>>,

    // records which block the database is synced to
    sync_label: Arc<Mutex<DbtSingleton<RustyKey, RustyValue, Digest>>>,

    // counts the number of output UTXOs generated by this wallet
    counter: Arc<Mutex<DbtSingleton<RustyKey, RustyValue, u64>>>,
}

impl RustyWalletDatabase {
    pub fn connect(db: DB) -> Self {
        let db_pointer = Arc::new(Mutex::new(db));
        let reader = RustyReader {
            db: db_pointer.clone(),
        };
        let reader_pointer = Arc::new(Mutex::new(reader));
        let mut schema = DbtSchema::<RustyKey, RustyValue, RustyReader> {
            tables: vec![],
            reader: reader_pointer,
        };

        let monitored_utxos_storage = schema.new_vec::<u64, MonitoredUtxo>("monitored_utxos");
        let balance_updates_storage = schema.new_vec::<u64, BalanceUpdate>("balance_updates");
        let sync_label_storage = schema.new_singleton::<Digest>(RustyKey("sync_label".into()));
        let counter_storage = schema.new_singleton::<u64>(RustyKey("counter".into()));

        Self {
            schema,
            db: db_pointer,
            monitored_utxos: monitored_utxos_storage,
            balance_updates: balance_updates_storage,
            sync_label: sync_label_storage,
            counter: counter_storage,
        }
    }

    pub fn get_sync_label(&self) -> Digest {
        self.sync_label.get()
    }

    pub fn set_sync_label(&mut self, sync_label: Digest) {
        self.sync_label.set(sync_label);
    }

    pub fn get_counter(&self) -> u64 {
        self.counter.get()
    }

    pub fn set_counter(&mut self, counter: u64) {
        self.counter.set(counter);
    }
}

impl StorageWriter<RustyKey, RustyValue> for RustyWalletDatabase {
    fn persist(&mut self) {
        let mut write_batch = WriteBatch::new();

        for table in &self.schema.tables {
            let operations = table
                .lock()
                .expect("Could not obtain lock on table in RustyWallet as StorageWriter (persist).")
                .pull_queue();
            for op in operations {
                match op {
                    WriteOperation::Write(key, value) => write_batch.put(&key.0, &value.0),
                    WriteOperation::Delete(key) => write_batch.delete(&key.0),
                }
            }
        }

        self.db
            .lock()
            .expect("RustyWallet: StorageWriter -- could not get lock on database for writing.")
            .write(write_batch, true)
            .expect("Could not persist to database.");
    }

    fn restore_or_new(&mut self) {
        for table in &self.schema.tables {
            table.lock().expect("Could not obtain lock on table in RustyWallet as StorageWriter (restore_or_new).").restore_or_new();
        }
    }
}
