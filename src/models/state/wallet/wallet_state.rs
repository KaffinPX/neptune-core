use anyhow::{bail, Result};
use itertools::Itertools;
use mutator_set_tf::util_types::mutator_set::mutator_set_accumulator::MutatorSetAccumulator;
use mutator_set_tf::util_types::mutator_set::mutator_set_trait::MutatorSet;
use mutator_set_tf::util_types::mutator_set::removal_record::RemovalRecord;
use num_traits::Zero;
use std::error::Error;
use std::sync::Arc;
use tokio::sync::Mutex as TokioMutex;
use tracing::{debug, info, warn};
use twenty_first::shared_math::b_field_element::BFieldElement;
use twenty_first::util_types::algebraic_hasher::AlgebraicHasher;

use mutator_set_tf::util_types::mutator_set::ms_membership_proof::MsMembershipProof;
use twenty_first::shared_math::rescue_prime_digest::{Digest, DIGEST_LENGTH};

use super::wallet_block_utxos::WalletBlockIOSums;
use super::wallet_status::{WalletStatus, WalletStatusElement};
use super::Wallet;
use crate::config_models::data_directory::DataDirectory;
use crate::database::leveldb::LevelDB;
use crate::database::rusty::RustyLevelDB;
use crate::models::blockchain::block::Block;
use crate::models::blockchain::transaction::utxo::Utxo;
use crate::models::blockchain::transaction::{Amount, Transaction};
use crate::models::database::{MonitoredUtxo, WalletDbKey, WalletDbValue};
use crate::models::state::wallet::wallet_block_utxos::WalletBlockUtxos;
use crate::Hash;

/// A wallet indexes its input and output UTXOs after blockhashes
/// so that one can easily roll-back. We don't want to serialize the
/// database handle, wherefore this struct exists.
#[derive(Debug, Clone)]
pub struct WalletState {
    // This value must be increased by one for each output.
    // Output counter counts number of outputs generated by this wallet. It does not matter
    // if these outputs are confirmed in a block or not. It adds one per output regardless.
    // The purpose of this value is to generate unique and deterministic entropy for each
    // new output.
    pub outgoing_utxo_counter_db: Arc<TokioMutex<RustyLevelDB<(), u128>>>,

    pub wallet_db: Arc<TokioMutex<RustyLevelDB<WalletDbKey, WalletDbValue>>>,
    pub wallet: Wallet,
}

impl WalletState {
    pub async fn new_from_wallet(data_dir: &DataDirectory, wallet: Wallet) -> Self {
        // Create or connect to wallet block DB
        let wallet_db = RustyLevelDB::<WalletDbKey, WalletDbValue>::new(
            &data_dir.wallet_database_dir_path(),
            rusty_leveldb::Options::default(),
        )
        .unwrap();
        let wallet_db = Arc::new(TokioMutex::new(wallet_db));

        // Create or connect to DB for output count
        let outgoing_utxo_count_db = RustyLevelDB::<(), u128>::new(
            &data_dir.wallet_output_count_database_dir_path(),
            rusty_leveldb::Options::default(),
        )
        .unwrap();
        let outgoing_utxo_counter_db = Arc::new(TokioMutex::new(outgoing_utxo_count_db));

        let ret = Self {
            outgoing_utxo_counter_db,
            wallet_db: wallet_db.clone(),
            wallet,
        };

        // Wallet state has to be initialized with the genesis block, otherwise the outputs
        // from it would be unspendable. This should only be done *once* though
        let mut wallet_db_lock = wallet_db.lock().await;
        if wallet_db_lock.get(WalletDbKey::SyncDigest).is_none() {
            ret.update_wallet_state_with_new_block(&Block::genesis_block(), &mut wallet_db_lock)
                .expect("Updating wallet state with genesis block must succeed");
        }

        ret
    }
}

impl WalletState {
    pub fn update_wallet_state_with_new_block(
        &self,
        block: &Block,
        wallet_db_lock: &mut tokio::sync::MutexGuard<RustyLevelDB<WalletDbKey, WalletDbValue>>,
    ) -> Result<()> {
        // A transaction contains a set of input and output UTXOs,
        // each of which contains an address (public key),

        let transaction: Transaction = block.body.transaction.clone();

        let my_pub_key = self.wallet.get_public_key();

        let input_utxos: Vec<Utxo> = transaction.get_own_input_utxos(my_pub_key);

        let output_utxos_commitment_randomness: Vec<(Utxo, Digest)> =
            transaction.get_own_output_utxos_and_comrands(my_pub_key);

        // Derive the membership proofs for new input UTXOs, *and* in the process update existing membership
        // proofs with updates from this block
        let mut monitored_utxos: Vec<MonitoredUtxo> = wallet_db_lock
            .get(WalletDbKey::MonitoredUtxos)
            .map(|x| x.as_monitored_utxos())
            .unwrap_or_default();

        // Let's not store the UTXOs of blocks that don't affect our balance
        if input_utxos.is_empty()
            && output_utxos_commitment_randomness.is_empty()
            && monitored_utxos.is_empty()
        {
            return Ok(());
        }

        let next_block_of_relevant_utxos =
            WalletBlockUtxos::new(input_utxos, output_utxos_commitment_randomness);

        let mut new_wallet_db_values: Vec<(WalletDbKey, WalletDbValue)> = vec![(
            WalletDbKey::WalletBlockUtxos(block.hash),
            WalletDbValue::WalletBlockUtxos(next_block_of_relevant_utxos),
        )];

        // Find the versions of the membership proofs that are from the latest block
        let mut own_membership_proofs: Vec<MsMembershipProof<Hash>> = vec![];
        let mut own_items_as_digests: Vec<Digest> = vec![];
        for mut monitored_utxo in monitored_utxos.iter_mut() {
            let utxo_digest = Hash::hash(&monitored_utxo.utxo);
            let relevant_membership_proof: Option<MsMembershipProof<Hash>> =
                monitored_utxo.get_membership_proof_for_block(&block.header.prev_block_digest);

            match relevant_membership_proof {
                Some(ms_mp) => {
                    debug!("Found valid mp for UTXO");
                    own_membership_proofs.push(ms_mp.to_owned());
                    own_items_as_digests.push(utxo_digest);
                    monitored_utxo.has_synced_membership_proof = true;
                }
                None => {
                    warn!(
                        "Unable to find membership proof for UTXO with digest {}",
                        utxo_digest
                    );
                    monitored_utxo.has_synced_membership_proof = false;
                }
            }
        }

        // Loop over all input UTXOs, applying all addition records
        let mut changed_mps = vec![];
        let mut msa_state: MutatorSetAccumulator<Hash> =
            block.body.previous_mutator_set_accumulator.to_owned();
        let mut removal_records = block.body.mutator_set_update.removals.clone();
        removal_records.reverse();
        let mut removal_records: Vec<&mut RemovalRecord<Hash>> =
            removal_records.iter_mut().collect::<Vec<_>>();
        for (mut addition_record, (utxo, commitment_randomness)) in block
            .body
            .mutator_set_update
            .additions
            .clone()
            .into_iter()
            .zip_eq(block.body.transaction.outputs.clone().into_iter())
        {
            let res: Result<Vec<usize>, Box<dyn Error>> =
                MsMembershipProof::batch_update_from_addition(
                    &mut own_membership_proofs.iter_mut().collect::<Vec<_>>(),
                    &own_items_as_digests,
                    &mut msa_state.set_commitment,
                    &addition_record,
                );
            match res {
                Ok(mut indices_of_mutated_mps) => changed_mps.append(&mut indices_of_mutated_mps),
                Err(_) => bail!("Failed to update membership proofs with addition record"),
            };

            // Batch update removal records to keep them valid after next addition
            RemovalRecord::batch_update_from_addition(
                &mut removal_records,
                &mut msa_state.set_commitment,
            )
            .expect("MS removal record update from add must succeed in wallet handler");

            // If output UTXO belongs to us, add it to the list of monitored UTXOs and
            // add its membership proof to the list of managed membership proofs.
            if utxo.matches_pubkey(self.wallet.get_public_key()) {
                // TODO: Change this logging to use `Display` for `Amount` once functionality is merged from t-f
                info!(
                    "Received UTXO in block {}, height {}: value = {:?}",
                    block.hash, block.header.height, utxo.amount
                );
                let utxo_digest = Hash::hash(&utxo);
                let new_own_membership_proof =
                    msa_state.prove(&utxo_digest, &commitment_randomness, true);

                own_membership_proofs.push(new_own_membership_proof);
                own_items_as_digests.push(utxo_digest);

                // In case of forks, it can happen that a UTXO is dropped from the abandoned chain
                // but exists in the new chain. If that's the case, then the membership proof was marked
                // as invalid above, but the membership proof in scope here is actually its real
                // membership proof. We fix this problem by deleting the old entry for monitored UTXO
                // (if it exists) and then just add the new one.
                let mut new_monitored_utxo = MonitoredUtxo::new(utxo);
                let forked_utxo_match = monitored_utxos
                    .iter()
                    .find_position(|x| !x.has_synced_membership_proof && x.utxo == utxo);
                if let Some((index_of_forked_utxo, forked_utxo)) = forked_utxo_match {
                    // If this is a forked UTXO (removed in abandoned chain, added in this)
                    // then we make sure to both remove the old entry from the `monitored_utxos`
                    // list *but* preserve the membership proofs associated with this old entry
                    // since we might have to fork back to this chain that is being abandoned.
                    // We remove the old entry since we are adding a new entry immediately
                    // below this if-block and we don't want to include this monitored UTXO twice.
                    info!(
                        "Own UTXO {} repeated in forked chain, recovering.",
                        Hash::hash(&forked_utxo.utxo)
                    );
                    new_monitored_utxo = monitored_utxos.remove(index_of_forked_utxo);
                    new_monitored_utxo.has_synced_membership_proof = true;
                }

                monitored_utxos.push(new_monitored_utxo);
            }

            // Update mutator set to bring it to the correct state for the next call to batch-update
            msa_state.add(&mut addition_record);
        }

        // sanity checks
        assert_eq!(
            monitored_utxos
                .iter()
                .filter(|x| x.has_synced_membership_proof)
                .count(),
            own_membership_proofs.len(),
            "Monitored UTXO count must match number of managed membership proofs"
        );
        assert_eq!(
            own_membership_proofs.len(),
            own_items_as_digests.len(),
            "Number of managed membership proofs must match number of own items"
        );

        // Loop over all output UTXOs, applying all removal records
        debug!("Block has {} removal records", removal_records.len());
        debug!(
            "Transaction has {} inputs",
            block.body.transaction.inputs.len()
        );
        let mut i = 0;
        while let Some(removal_record) = removal_records.pop() {
            let res = MsMembershipProof::batch_update_from_remove(
                &mut own_membership_proofs.iter_mut().collect::<Vec<_>>(),
                removal_record,
            );
            match res {
                Ok(mut indices_of_mutated_mps) => changed_mps.append(&mut indices_of_mutated_mps),
                Err(_) => bail!("Failed to update membership proofs with removal record"),
            };

            // Batch update removal records to keep them valid after next removal
            RemovalRecord::batch_update_from_remove(&mut removal_records, removal_record)
                .expect("MS removal record update from remove must succeed in wallet handler");

            // TODO: We mark membership proofs as spent, so they can be deleted. But
            // how do we ensure that we can recover them in case of a fork? For now we maintain
            // them even if the are spent, and then, later, we can add logic to remove these
            // membership proofs of spent UTXOs once they have been spent for M blocks.
            let input_utxo = block.body.transaction.inputs[i].utxo;
            if input_utxo.matches_pubkey(my_pub_key) {
                debug!(
                    "Discovered own input at input {}, marking UTXO as spent.",
                    i
                );

                let input_utxo_digest = Hash::hash(&input_utxo);
                let mut matching_utxos: Vec<&mut MonitoredUtxo> = monitored_utxos
                    .iter_mut()
                    .filter(|monitored_utxo| Hash::hash(&monitored_utxo.utxo) == input_utxo_digest)
                    .collect();
                match matching_utxos.len() {
                    0 => panic!(
                        "Discovered own input UTXO in block that did not match a monitored UTXO"
                    ),
                    1 => {
                        matching_utxos[0].spent_in_block =
                            Some((block.hash, block.header.height, block.header.timestamp));
                    }
                    _n => {
                        // If we are monitoring multiple UTXOs with the same hash, we need another
                        // method to mark the correct UTXO as spent. In DevNet we use the membership
                        // proof from the block for this. In MainNet, where the input membership
                        // proofs are not included in the blocks, we can probably just check which
                        // of our own membership proofs that have become invalid with this block.
                        let matching_monitored_utxo = matching_utxos
                            .iter_mut()
                            .find(|monitored_utxo| {
                                let monitored_utxo_data_index = monitored_utxo
                                    .get_membership_proof_for_block(&block.header.prev_block_digest)
                                    .unwrap()
                                    .auth_path_aocl
                                    .leaf_index;
                                let ms_membership_proof_data_index = block.body.transaction.inputs
                                    [i]
                                    .membership_proof
                                    .auth_path_aocl
                                    .leaf_index;

                                monitored_utxo_data_index == ms_membership_proof_data_index
                            })
                            .unwrap();

                        matching_monitored_utxo.spent_in_block =
                            Some((block.hash, block.header.height, block.header.timestamp));
                    }
                }
            }

            msa_state.remove(removal_record);
            i += 1;
        }

        // Sanity check that `msa_state` agrees with the mutator set from the applied block
        assert_eq!(
            block
                .body
                .next_mutator_set_accumulator
                .clone()
                .get_commitment(),
            msa_state.get_commitment(),
            "Mutator set in wallet-handler must agree with that from applied block"
        );

        changed_mps.sort();
        changed_mps.dedup();
        debug!("Number of mutated membership proofs: {}", changed_mps.len());
        debug!(
            "Number of unspent membership proofs: {}",
            monitored_utxos
                .iter()
                .filter(|x| x.spent_in_block.is_none())
                .count()
        );

        for (monitored_utxo, updated_mp) in monitored_utxos
            .iter_mut()
            .filter(|x| x.has_synced_membership_proof)
            .zip_eq(own_membership_proofs)
        {
            // Sanity check that all membership proofs are valid for the next mutator set defined
            // by this block
            assert!(
                monitored_utxo.spent_in_block.is_some()
                    || msa_state.verify(&Hash::hash(&monitored_utxo.utxo), &updated_mp),
                "{}",
                format!(
                    "Updated membership proof for unspent UTXO must be valid. Invalid: {:?}",
                    monitored_utxo
                )
            );

            // Add the new membership proof to the list of membership proofs for this UTXO
            monitored_utxo.add_membership_proof_for_tip(block.hash, updated_mp);
        }

        new_wallet_db_values.push((
            WalletDbKey::MonitoredUtxos,
            WalletDbValue::MonitoredUtxos(monitored_utxos),
        ));

        // Push block hash for which wallet has been updated
        new_wallet_db_values.push((
            WalletDbKey::SyncDigest,
            WalletDbValue::SyncDigest(block.hash),
        ));

        wallet_db_lock.batch_write(&new_wallet_db_values);

        Ok(())
    }

    fn get_monitored_utxos_with_lock(
        &self,
        lock: &mut RustyLevelDB<WalletDbKey, WalletDbValue>,
    ) -> Vec<MonitoredUtxo> {
        lock.get(WalletDbKey::MonitoredUtxos)
            .map(|x| x.as_monitored_utxos())
            .unwrap_or_default()
    }

    // Blocking call to get the monitored UTXOs.
    pub async fn get_monitored_utxos(&self) -> Vec<MonitoredUtxo> {
        let mut lock = self.wallet_db.lock().await;
        self.get_monitored_utxos_with_lock(&mut lock)
    }

    pub async fn get_balance(&self) -> Amount {
        let sums: WalletBlockIOSums = self
            .wallet_db
            .lock()
            .await
            .new_iter()
            .filter(|(_key, value)| value.is_wallet_block_utxos())
            .map(|(_key, value)| value.as_wallet_block_utxos())
            .map(|wallet_block| wallet_block.get_io_sums())
            .reduce(|a, b| a + b)
            .unwrap_or_default();
        sums.output_sum - sums.input_sum
    }

    fn get_wallet_status_with_lock(
        &self,
        lock: &mut RustyLevelDB<WalletDbKey, WalletDbValue>,
    ) -> WalletStatus {
        let m_utxos = self.get_monitored_utxos_with_lock(lock);
        let synced_unspent: Vec<(WalletStatusElement, MsMembershipProof<Hash>)> = m_utxos
            .iter()
            .filter(|x| x.spent_in_block.is_none() && x.has_synced_membership_proof)
            .map(|x| {
                let ms_mp = x.get_latest_membership_proof();
                (
                    WalletStatusElement(ms_mp.auth_path_aocl.leaf_index, x.utxo),
                    ms_mp,
                )
            })
            .collect();
        let unsynced_unspent: Vec<WalletStatusElement> = m_utxos
            .iter()
            .filter(|x| x.spent_in_block.is_none() && !x.has_synced_membership_proof)
            .map(|x| {
                WalletStatusElement(
                    x.get_latest_membership_proof().auth_path_aocl.leaf_index,
                    x.utxo,
                )
            })
            .collect();
        let synced_spent: Vec<WalletStatusElement> = m_utxos
            .iter()
            .filter(|x| x.spent_in_block.is_some() && x.has_synced_membership_proof)
            .map(|x| {
                WalletStatusElement(
                    x.get_latest_membership_proof().auth_path_aocl.leaf_index,
                    x.utxo,
                )
            })
            .collect();
        let unsynced_spent: Vec<WalletStatusElement> = m_utxos
            .iter()
            .filter(|x| x.spent_in_block.is_some() && !x.has_synced_membership_proof)
            .map(|x| {
                WalletStatusElement(
                    x.get_latest_membership_proof().auth_path_aocl.leaf_index,
                    x.utxo,
                )
            })
            .collect();
        WalletStatus {
            synced_unspent_amount: synced_unspent.iter().map(|x| x.0 .1.amount).sum(),
            synced_unspent,
            unsynced_unspent_amount: unsynced_unspent.iter().map(|x| x.1.amount).sum(),
            unsynced_unspent,
            synced_spent_amount: synced_spent.iter().map(|x| x.1.amount).sum(),
            synced_spent,
            unsynced_spent_amount: unsynced_spent.iter().map(|x| x.1.amount).sum(),
            unsynced_spent,
        }
    }

    pub async fn get_wallet_status(&self) -> WalletStatus {
        let mut lock = self.wallet_db.lock().await;
        self.get_wallet_status_with_lock(&mut lock)
    }

    #[allow(dead_code)]
    async fn forget_block(&self, block_hash: Digest) {
        self.wallet_db
            .lock()
            .await
            .delete(WalletDbKey::WalletBlockUtxos(block_hash));
    }

    /// Fetch the output counter from the database and increase the counter by one
    async fn next_output_counter(&self) -> u128 {
        let mut outgoing_utxo_counter_lock = self.outgoing_utxo_counter_db.lock().await;
        let current_counter: u128 = outgoing_utxo_counter_lock.get(()).unwrap_or_default();
        outgoing_utxo_counter_lock.put((), current_counter + 1);

        current_counter
    }

    /// Get the randomness for the next output UTXO and increment the output counter by one
    pub async fn next_output_randomness(&self) -> Digest {
        let counter = self.next_output_counter().await;

        // TODO: Ugly hack used to generate a `Digest` from a `u128` here.
        // Once we've updated to twenty-first 0.2.0 or later use its `to_sequence` instead.
        let mut counter_as_digest: Vec<BFieldElement> = vec![BFieldElement::zero(); DIGEST_LENGTH];
        counter_as_digest[0] = BFieldElement::new(counter as u64);
        let counter_as_digest: Digest = counter_as_digest.try_into().unwrap();
        let commitment_pseudo_randomness_seed = self.wallet.get_commitment_randomness_seed();

        Hash::hash_pair(&counter_as_digest, &commitment_pseudo_randomness_seed)
    }

    pub fn allocate_sufficient_input_funds_with_lock(
        &self,
        lock: &mut RustyLevelDB<WalletDbKey, WalletDbValue>,
        requested_amount: Amount,
    ) -> Result<Vec<(Utxo, MsMembershipProof<Hash>)>> {
        // We only attempt to generate a transaction using those UTXOs that have up-to-date
        // membership proofs.
        let wallet_status: WalletStatus = self.get_wallet_status_with_lock(lock);

        // First check that we have enough. Otherwise return an error.
        if wallet_status.synced_unspent_amount < requested_amount {
            // TODO: Change this to `Display` print once available.
            bail!("Insufficient synced amount to create transaction. Requested: {:?}, synced available amount: {:?}", requested_amount, wallet_status.synced_unspent_amount);
        }

        let mut ret: Vec<(Utxo, MsMembershipProof<Hash>)> = vec![];
        let mut allocated_amount = Amount::zero();
        while allocated_amount < requested_amount {
            let next_elem = wallet_status.synced_unspent[ret.len()].clone();
            allocated_amount = allocated_amount + next_elem.0 .1.amount;
            ret.push((next_elem.0 .1, next_elem.1));
        }

        Ok(ret)
    }

    // Allocate sufficient UTXOs to generate a transaction. `amount` must include fees that are
    // paid in the transaction.
    pub async fn allocate_sufficient_input_funds(
        &self,
        requested_amount: Amount,
    ) -> Result<Vec<(Utxo, MsMembershipProof<Hash>)>> {
        let mut lock = self.wallet_db.lock().await;
        self.allocate_sufficient_input_funds_with_lock(&mut lock, requested_amount)
    }
}

#[cfg(test)]
mod wallet_state_tests {
    use crate::tests::shared::get_mock_wallet_state;

    #[tokio::test]
    async fn increase_output_counter_test() {
        // Verify that output counter is incremented when the counter value is fetched
        let wallet_state = get_mock_wallet_state(None).await;
        for i in 0..12 {
            assert_eq!(
                i,
                wallet_state.next_output_counter().await,
                "Output counter must match number of calls"
            );
        }
    }
}
